<script>
const MAX_VISIBLE_META_TAGS = 3;

const publications = [
  {
    title: "Scaling Terraform agents using the Terraform Operator on Amazon EKS Auto Mode",
    description: "Demo with provided Terraform code and screenshots that show how Terraform agents autoscale using the Terraform Operator on EKS Auto Mode",
    detailed_description: "HashiCorp Cloud Platform (HCP) Terraform provides managed infrastructure automation with multiple execution modes, including HCP Terraform Agents that are self-hosted execution environments ideal for managing resources in private networks while maintaining HCP Terraform's collaborative features. As organizations scale, manually managing these agents becomes complex, with platform teams struggling to balance sufficient capacity for peak workloads against resource waste during quiet periods.<br><br>The solution lies in combining two complementary autoscaling technologies: the HCP Terraform Operator for Kubernetes automatically scales the number of agent pods based on pending Terraform workspace workloads, ensuring sufficient capacity during high demand periods while conserving resources during low utilization without manual intervention. Meanwhile, Amazon EKS Auto Mode that comes with Karpenter handles the underlying infrastructure layer by intelligently scaling cluster nodes based on pod scheduling needs. When Terraform runs spike and the operator creates new agent pods, Karpenter observes these unschedulable pods and launches new nodes to accommodate them. Conversely, when workspace activity decreases and the operator scales down agent pods, Karpenter consolidates workloads and terminates unused nodes. This two-tier autoscaling approach creates an intelligent, self-adjusting solution where the operator focuses on application-level scaling driven by actual Terraform workspace demand, while EKS Auto Mode focuses on infrastructure-level scaling, together optimizing both performance and cost without requiring manual capacity management.<br><br>To help you experience this autoscaling solution firsthand, the accompanying GitHub repository provides complete sample code that provisions an EKS Auto Mode cluster, deploys the HCP Terraform Operator using a Helm chart on system nodes, and configures agent pools to run on general purpose nodes. The repository also includes code to create test workspaces that generate varying workload patterns, allowing you to observe how the operator dynamically scales agent pods in response to workspace demand while Karpenter simultaneously adjusts the underlying node infrastructure, demonstrating the coordination between application-level and infrastructure-level autoscaling in action.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["terraform", "operator", "agent", "kubernetes", "eks auto mode", "aws"],
    link: "https://medium.com/hashicorp-engineering/scaling-terraform-agents-on-amazon-eks-auto-mode-for-efficient-infrastructure-management-1d64b5cb74fc",
    code_link: "https://github.com/GlennChia/terraform-operator-agent-eks-auto-mode",
    folder: "hashicorp-terraform-agent-operator-eks-auto-mode",
    date: "2025-09-15"
  },
  {
    title: "Cross-region connections from consumers to Vault using AWS PrivateLink",
    description: "Code and screenshots that show how to establish secure cross-region connections to HCP Vault Dedicated using AWS PrivateLink",
    detailed_description: "AWS PrivateLink provides a secure way to access services privately without exposing traffic to the public internet. HCP Vault now supports AWS PrivateLink connectivity, allowing consumers to securely connect to Vault clusters in different AWS regions while keeping all traffic within the AWS network backbone. This feature requires a HCP Vault Dedicated Essentials or Standard tier cluster.<br><br>In this post, we'll explore how to establish cross-region connections to HCP Vault clusters using AWS PrivateLink, verify the deployed resources, and demonstrate basic Vault operations through the secure connection.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["vault", "hcp", "privatelink", "network", "inbound"],
    link: "https://www.hashicorp.com/en/resources/cross-region-connections-from-consumers-to-vault-using-aws-privatelink",
    code_link: "https://github.com/GlennChia/hcp-vault-cross-region-privatelink",
    folder: "hashicorp-vault-cross-region-private-link",
    date: "2025-10-14"
  },
  {
    title: "Patterns for connecting Vault to Amazon RDS using Amazon VPC Lattice",
    description: "Architecture diagrams documenting the various ways of using Amazon VPC Lattice to achieve private connectivity from Vault to Amazon RDS without connecting provider VPCs using VPC peering or Transit Gateway",
    detailed_description: "This is part 1 of a three-part series that highlights how Amazon VPC Lattice can help you achieve private connectivity from Vault self-managed (refers to Vault Enterprise or Vault Community Edition) or HCP Vault Dedicated to resources like Amazon RDS without direct connections to the RDS VPC via VPC peering or AWS Transit Gateway.<br><br>Amazon VPC Lattice allows private connectivity only to resources that you specify instead of the entire VPC. VPC Lattice is a fully managed application networking service that helps you simplify network connectivity, security, and monitoring for service-to-service communication needs. It also has broad support for the most common types of services and protocols, such as HTTP and HTTPS, gRPC, TLS, and TCP. In this blog, we will explore various ways we can leverage VPC Lattice features to connect Vault self-managed and HCP Vault Dedicated to RDS while ensuring the VPC hosting RDS, referred to as the Provider VPC, remains isolated from all other VPCs. This means that the provider VPCs will not be connected to other VPCs via VPC peering or Transit Gateway.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["vault", "network", "lattice", "outbound"],
    link: "https://www.hashicorp.com/en/blog/patterns-for-connecting-vault-to-amazon-rds-using-amazon-vpc-lattice",
    folder: "hashicorp-vault-outbound-lattice-patterns",
    date: "2025-06-30"
  },
  {
    title: "Connecting Vault to Amazon RDS using Amazon VPC Lattice",
    description: "Architecture diagram documenting the Lattice Service Network Endpoint pattern with Vault self-managed. Includes screenshots showing how it was tested",
    detailed_description: "Part two of a three-part series showing how VPC Lattice can help achieve private connectivity from Vault self-managed (refers to Vault Enterprise or Vault Community Edition) to resources like Amazon RDS without direct connections to the RDS VPC via VPC Peering or Transit Gateway. This guide demonstrates implementing the database secrets engine use case, featuring screenshots of the required AWS resources and validation tests for dynamic secret creation.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["vault", "self-manage", "network", "lattice", "outbound", "database secrets engine"],
    link: "https://www.hashicorp.com/en/blog/connecting-vault-to-amazon-rds-using-amazon-vpc-lattice",
    folder: "hashicorp-vault-ent-outbound-lattice-patterns",
    date: "2025-06-30"
  },
  {
    title: "Connecting HCP Vault Dedicated to Amazon RDS privately using Amazon VPC Lattice",
    description: "Architecture diagram documenting the Lattice Service Network Endpoint pattern with HCP Vault Dedicated. Includes screenshots showing how it was tested",
    detailed_description: "Part three of a three-part series showing how VPC Lattice can help achieve private connectivity from HCP Vault Dedicated to resources like Amazon RDS without direct connections to the RDS VPC via VPC peering or Transit Gateway. This guide demonstrates implementing the database secrets engine use case, featuring screenshots of the required AWS resources and validation tests for dynamic secret creation.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["vault", "hcp", "network", "lattice", "outbound", "database secrets engine"],
    link: "https://www.hashicorp.com/en/blog/connecting-hcp-vault-dedicated-to-amazon-rds-privately-using-amazon-vpc-lattice",
    folder: "hashicorp-vault-hcp-outbound-lattice-patterns",
    date: "2025-06-30"
  },
  {
    title: "Enforce private module registry usage in Terraform with Sentinel",
    description: "Step by step guide on using Sentinel policy as code in HCP Terraform to ensure developers are only using approved infrastructure modules.",
    detailed_description: "Step by step guide that shows how to<br><br>1. Craft a Sentinel policy that enforces the use of your private module registry<br>2. Pass parameters to the Sentinel policy<br>3. Connect the policy set using VCS and enforce it globally<br>4. Test the policy set",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["terraform", "sentinel", "registry", "module", "policy as code"],
    link: "https://www.hashicorp.com/en/blog/enforce-private-module-registry-usage-in-terraform-with-sentinel",
    folder: "terraform",
    date: "2025-07-29"
  },
  {
    title: "HashiTalks: Terraform Module Lifecycle with Deprecation, Explorer, Change Requests, and Notifications",
    description: "Code provided to bootstrap demo with the video providing a step by step walkthrough on features like module deprecation, revocation, explorer views, change request creation, and notifications",
    detailed_description: "This video goes through the Terraform module lifecycle and covers the following<br><br>1. Module semantic versioning and publishing workflow<br>2. Module lifecycle with deprecation, revocation, and the resulting workspace consumption behavior<br>3. Setting up Terraform Teams and notifications<br>4. Using the explorer to filter to non-latest module versions<br>5. Creating change requests and receiving email notifications",
    job: "HashiCorp",
    content_type: "video",
    tags: ["terraform", "module", "lifecycle", "deprecate", "revoke", "explorer", "change request", "notification"],
    link: "https://www.youtube.com/live/PtUx4jLG954?si=kGJYmDEDQdzkthQI&t=3337",
    code_link: "https://github.com/GlennChia/hashitalks-terraform-module-lifecycle/tree/main/bootstrap",
    folder: "terraform",
    popup_folder: "hashicorp-terraform-module-lifecycle",
    date: "2025-11-30"
  },
  {
    title: "Integrate HCP Packer with Red Hat Ansible Automation Platform",
    description: "Architecture diagrams showing how to integrate Packer with Ansible and Ansible Automation Platform with sample code snippets provided.",
    detailed_description: "The objective of this validated pattern is to assist you in deploying a comprehensive immutable image building pipeline that combines the power of HashiCorp Packer for image creation with Ansible for configuration management. Has a section on documenting the benefits of using Ansible Automation Platform (AAP) over using the basic Ansible provisioner alone.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["packer", "aap", "ansible", "golden image", "vault", "ssh secrets engine"],
    link: "https://developer.hashicorp.com/validated-patterns/packer/integrate-hcp-packer-with-ansible-automation-platform",
    folder: "hashicorp-redhat",
    popup_folder: "hashicorp-packer-redhat-aap",
    date: "2025-09-12"
  },
  {
    title: "Amazon Q Developer and HashiCorp Terraform MCP server",
    description: "Step by step guide on using the Terraform MCP server with Q Developer. Demo uses the Q developer to generate code and identify deprecated arguments based on a provider version",
    detailed_description: "Step by step guide on using the Terraform MCP server with Q Developer. Demo uses the Q developer to generate code and identify deprecated arguments based on a provider version.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["terraform", "genai", "mcp", "q developer"],
    link: "https://www.hashicorp.com/en/resources/enhance-infrastructure-development-amazon-q-developer-hashicorp-terraform-mcp-server",
    folder: "hashicorp-terraform-mcp-q-developer",
    date: "2025-08-28"
  },
  {
    title: "AWS and AWSCC Terraform providers: Better together",
    description: "Sample code, step by step guide showing how to use both providers together and how to migrate from one provider to the other with import and removed blocks",
    detailed_description: "Terraform has two AWS providers: AWS and AWSCC, one handwritten, the other automatically generated. This post covers the reasoning behind these approaches, how each provider interacts with AWS APIs, how they complement rather than compete with each other, and how to migrate resources from one provider to the other, without recreating them.",
    job: "HashiCorp",
    content_type: "blog",
    tags: ["terraform", "provider", "awscc", "aws", "import", "removed"],
    link: "https://www.hashicorp.com/en/blog/aws-and-awscc-terraform-providers-better-together",
    folder: "terraform-aws",
    date: "2025-04-24"
  },
  {
    title: "terraform-provider-vault: Fix eventual consistency for <i>vault_aws_auth_backend_role</i>",
    description: "Pull request that supports eventual consistency for the <i>vault_aws_auth_backend_role</i> resource in the terraform-provider-vault repository",
    detailed_description: "The pull request linked shows how to add support for eventual consistency to resources in the Terraform Vault provider. This can be a template for other resources that might require eventual consistency. In this example, after an IAM principal is created, it takes time for the permissions to propagate leading to errors when creating the <i>vault_aws_auth_backend_role</i> immediately after the IAM principal is created. Hence, if there are 400 errors, retry within an acceptable period.",
    job: "HashiCorp",
    content_type: "pr",
    tags: ["terraform", "provider", "dev", "vault"],
    link: "https://github.com/hashicorp/terraform-provider-vault/pull/2440",
    folder: "terraform",
    date: "2025-03-25"
  },
  {
    title: "HashiTalks: Migrate Terraform state between the AWS and AWSCC providers",
    description: "Video walkthrough of how to use the providers together, migrating state between providers for resources, migrating state between providers for modules, handling edge cases, and converting code between the providers with GenAI",
    detailed_description: "Video walkthrough with screenshots of how to use the providers together, migrating state between providers for resources, migrating state between providers for modules, handling edge cases, and converting code between the providers with GenAI.",
    job: "HashiCorp",
    content_type: "video",
    tags: ["terraform", "provider", "awscc", "aws", "import", "removed"],
    link: "https://www.youtube.com/watch?v=LdAglxXbFH8",
    folder: "terraform-aws",
    date: "2024-09-13"
  },
  {
    title: "HashiTalks: Testing for backward compatibility when developing Terraform AWS Provider resources",
    description: "Video walkthrough of making code contributions to the open-source terraform-provider-aws repository. Talk focuses on coding for backward compatibility and writing tests to validate the developed code",
    detailed_description: "Video walkthrough of making code contributions to the open-source terraform-provider-aws repository. Talk focuses on coding for backward compatibility and writing tests to validate the developed code.",
    job: "HashiCorp",
    content_type: "video",
    tags: ["terraform", "provider", "dev", "aws"],
    link: "https://www.youtube.com/watch?v=OQ3xpNUJnks",
    code_link: "https://github.com/hashicorp/terraform-provider-aws/pull/31035",
    folder: "terraform-aws",
    date: "2023-08-11"
  },
];

function renderPublications(filteredPublications) {
  const grid = document.getElementById('publications-grid');
  const count = document.getElementById('results-count');

  count.textContent = filteredPublications.length;

  grid.innerHTML = filteredPublications.map(pub => `
    <div class="publication-card" data-job="${pub.job}" data-content-type="${pub.content_type}" onclick="showModal(${JSON.stringify(pub).replace(/"/g, '&quot;')})" style="cursor: pointer;">
      <h3 class="card-title">${pub.title}</h3>
      ${pub.folder ? `<div class="card-diagram"><img src="/assets/publications/${pub.folder}/architecture.png" alt="Architecture diagram" onerror="this.style.display='none'"></div>` : ''}
      <p class="card-description">${pub.description}</p>
      <div class="card-footer">
        <div class="card-tags" data-all-tags='${JSON.stringify(pub.tags)}'>
          <span class="tag company-tag">${pub.job}</span>
          <span class="tag type-tag">${pub.content_type}</span>
          ${pub.tags.map(tag => `<span class="tag meta-tag" data-tag="${tag}">${tag}</span>`).join('')}
        </div>
        <button class="view-button" onclick="event.stopPropagation(); showModal(${JSON.stringify(pub).replace(/"/g, '&quot;')})">View</button>
      </div>
    </div>
  `).join('');

  // Apply dynamic tag overflow after rendering
  setTimeout(() => {
    document.querySelectorAll('.card-tags').forEach(handleTagOverflow);
  }, 100);
}

function handleTagOverflow(tagsContainer) {
  const allTags = JSON.parse(tagsContainer.dataset.allTags);
  const metaTags = tagsContainer.querySelectorAll('.meta-tag');
  const existingOverflow = tagsContainer.querySelector('.tag-overflow');
  
  if (existingOverflow) existingOverflow.remove();

  // Reset all meta tags to visible first
  metaTags.forEach(tag => tag.style.display = '');

  // Get container and button widths
  const footer = tagsContainer.parentElement;
  const viewButton = footer.querySelector('.view-button');
  const footerWidth = footer.offsetWidth;
  const buttonWidth = viewButton.offsetWidth;
  const availableWidth = footerWidth - buttonWidth - 40; // Extra buffer for gaps and padding

  // Calculate current width of all visible tags
  let currentWidth = 0;
  const allVisibleTags = tagsContainer.querySelectorAll('.tag:not(.tag-overflow)');
  allVisibleTags.forEach(tag => {
    currentWidth += tag.offsetWidth + 6; // 6px gap
  });

  // If current width exceeds available width, start hiding meta tags
  if (currentWidth > availableWidth) {
    const fixedTags = tagsContainer.querySelectorAll('.company-tag, .type-tag');
    let fixedWidth = 0;
    fixedTags.forEach(tag => fixedWidth += tag.offsetWidth + 6);

    let visibleMetaTags = 0;
    let metaWidth = fixedWidth;
    
    for (let i = 0; i < metaTags.length; i++) {
      const tagWidth = metaTags[i].offsetWidth + 6;
      // Reserve space for +N indicator (approximately 30px)
      if (metaWidth + tagWidth + 30 > availableWidth) break;
      metaWidth += tagWidth;
      visibleMetaTags++;
    }

    // Hide overflow tags and show + indicator
    if (visibleMetaTags < metaTags.length) {
      const hiddenTags = allTags.slice(visibleMetaTags);
      
      for (let i = visibleMetaTags; i < metaTags.length; i++) {
        metaTags[i].style.display = 'none';
      }

      const overflowSpan = document.createElement('span');
      overflowSpan.className = 'tag-overflow';
      overflowSpan.textContent = `+${hiddenTags.length}`;
      overflowSpan.onmouseover = (e) => showTagTooltip(e, hiddenTags);
      overflowSpan.onmouseout = hideTagTooltip;
      
      // Add click handler for mobile
      overflowSpan.onclick = (e) => {
        e.stopPropagation();
        if (window.innerWidth <= 768) {
          const card = tagsContainer.closest('.publication-card');
          const pubData = JSON.parse(card.getAttribute('onclick').match(/showModal\((.*?)\)/)[1].replace(/&quot;/g, '"'));
          showModal(pubData);
        }
      };
      
      tagsContainer.appendChild(overflowSpan);
    }
  }
}

function filterPublications() {
  const searchTerm = document.getElementById('search-input').value.toLowerCase();
  const activeFilters = {
    job: Array.from(document.querySelectorAll('.filter-checkbox[data-filter="job"]:checked')).map(cb => cb.value),
    content_type: Array.from(document.querySelectorAll('.filter-checkbox[data-filter="content_type"]:checked')).map(cb => cb.value),
    domain: Array.from(document.querySelectorAll('.filter-checkbox[data-filter="domain"]:checked')).map(cb => cb.value)
  };

  const filtered = publications.filter(pub => {
    const matchesSearch = !searchTerm ||
      pub.title.toLowerCase().includes(searchTerm) ||
      pub.description.toLowerCase().includes(searchTerm) ||
      pub.tags.some(tag => tag.toLowerCase().includes(searchTerm));

    const matchesJob = activeFilters.job.length === 0 || activeFilters.job.includes(pub.job);
    const matchesType = activeFilters.content_type.length === 0 || activeFilters.content_type.includes(pub.content_type);
    const matchesDomain = activeFilters.domain.length === 0 || activeFilters.domain.some(domain =>
      pub.tags.some(tag => tag.toLowerCase().includes(domain.toLowerCase()))
    );

    return matchesSearch && matchesJob && matchesType && matchesDomain;
  });

  renderPublications(filtered);
}

// Initial render
renderPublications(publications);

function showTagTooltip(event, tags) {
  const tooltip = document.createElement('div');
  tooltip.className = 'tag-tooltip';
  tooltip.innerHTML = tags.map(tag => `<span class="tag meta-tag">${tag}</span>`).join('');

  event.target.appendChild(tooltip);
}

function hideTagTooltip() {
  document.querySelectorAll('.tag-tooltip').forEach(tooltip => tooltip.remove());
}

function showModal(pub) {
  const modal = document.getElementById('publication-modal');
  const modalTitle = document.getElementById('modal-title');
  const modalTags = document.getElementById('modal-tags');
  const modalDate = document.getElementById('modal-date');
  const modalDiagram = document.getElementById('modal-diagram');
  const modalDescription = document.getElementById('modal-description');
  const modalLinks = document.getElementById('modal-links');

  modalTitle.innerHTML = pub.title;
  
  // Tags
  modalTags.innerHTML = `
    <span class="tag company-tag">${pub.job}</span>
    <span class="tag type-tag">${pub.content_type}</span>
    ${pub.tags.map(tag => `<span class="tag meta-tag">${tag}</span>`).join('')}
  `;
  
  modalDate.textContent = new Date(pub.date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  // Architecture diagram
  if (pub.popup_folder || pub.folder) {
    const imagePath = pub.popup_folder || pub.folder;
    modalDiagram.innerHTML = `<img src="/assets/publications/${imagePath}/architecture.png" alt="Architecture diagram" class="modal-diagram-img" onerror="this.style.display='none'">`;
  } else {
    modalDiagram.innerHTML = '';
  }

  modalDescription.innerHTML = pub.detailed_description.replace(/\n/g, '<br>');

  // Links
  let linksHTML = '<div class="modal-links-container">';

  if (pub.link) {
    linksHTML += `<a href="${pub.link}" target="_blank" class="modal-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z"/>
      </svg>
      View Publication
    </a>`;
  }

  if (pub.code_link) {
    linksHTML += `<a href="${pub.code_link}" target="_blank" class="modal-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"/>
      </svg>
      GitHub
    </a>`;
  }

  if (pub.video_link) {
    linksHTML += `<a href="${pub.video_link}" target="_blank" class="modal-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
      </svg>
      Video
    </a>`;
  }

  linksHTML += '</div>';
  modalLinks.innerHTML = linksHTML;

  modal.style.display = 'block';
}

function closeModal() {
  document.getElementById('publication-modal').style.display = 'none';
}

document.getElementById('search-input').addEventListener('input', filterPublications);
document.querySelectorAll('.filter-checkbox').forEach(cb => {
  cb.addEventListener('change', filterPublications);
});

document.getElementById('clear-filters').addEventListener('click', () => {
  document.getElementById('search-input').value = '';
  document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
  filterPublications();
});

// Modal event listeners
window.onclick = function(event) {
  const modal = document.getElementById('publication-modal');
  if (event.target === modal) {
    closeModal();
  }
}

// Recalculate tag overflow on window resize
window.addEventListener('resize', () => {
  document.querySelectorAll('.card-tags').forEach(handleTagOverflow);
});
</script>
